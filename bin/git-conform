#!/usr/bin/env ruby

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '..', 'lib')

begin
  require 'git-conform'
rescue LoadError
  require 'rubygems'
  require 'git-conform'
end

options = Trollop::options do

  version Git::Conform::COPYRIGHT
  banner Git::Conform::BANNER

  opt :available, 'List all available conformity checkers',                :short => 'a', :default => false
  opt :files,     'List all files in the git repo that will be processed', :short => 'f', :default => false
  opt :list,      'List all conformity checkers for this repo',            :short => 'l', :default => false
  opt :verify,    'Verify that all conformity checkers exist',             :short => 'e', :default => false
  opt :check,     'Run all conformity checkers',                           :short => 'c', :default => false

end

if options[:available]
  exit 0
end

repo = begin
  Git::Conform::Repo.new(Git::Conform::Repo.discover(Dir.pwd))
rescue RuntimeError
  unless $!.message =~ /The given path is not a valid Git repository/
    unless $!.message =~ /Not a git repository \(or any of the parent directories\)/
      raise # Rugged uses generic RuntimeErrors, so we have to check the exception messages...
    end
  end
  nil
end

unless repo
  STDERR.puts "fatal: Not a git repository (or any of the parent directories): #{Dir.pwd}"
  exit -1
end

if options[:files]
  unless (files = repo.files).empty?
    STDOUT.puts files.sort.join("\n")
  end
  exit 0
end

unless repo.git_conform_enabled?
  STDERR.puts "fatal: unable to read config file '#{repo.git_conform_path}': No such file or directory"
  exit -1
end

if options[:list]
  unless (checkers = repo.conformity_checkers).empty?
    STDOUT.puts checkers.sort.join("\n")
  end
  exit 0
end

if options[:verify]
  begin
    repo.verify
  rescue NameError
    STDERR.puts "fatal: #{$!.message}"
    exit -1
  end
  exit 0
end

if options[:check]
  repo.conformity_checkers.each do |checker_class|
    checker_class = constantize "Git::Conform::#{checker_class}"
    puts checker_class.name.inverse
    repo.files.each do |filename|
      checker_class.new(filename).check_conformity do |filename|
        puts ">>> " + filename
      end
    end
  end
  exit 0
end

fail "Coming soon!"

# That's all, Folks!